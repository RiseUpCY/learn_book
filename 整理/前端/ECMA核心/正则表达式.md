# 正则表达式

## 基本知识

### 规则

```js
// 创建正则
let reg = new RegExp(str)
let reg = /asd/

// 规则
// ^n       以n开始
// n$       以n结尾

/* 正向预查
    ?:n      包含括号中的表达式
    ?=n      let reg = /a(?=bb)/  找查跟着两个b的a
    ?!n      let reg = /a(?!bb)/  找查没有跟着两个b的a
 * */
// 例如： /^(.(?![@#$%￥…]))*$/    正向反预查，不包含某些字符的字符串
// 例如：
var data = "windows 98 is ok"
data.match(/windows (?=\d+)/) // ["windows "]
data.match(/windows (?:\d+)/) // ["windows 98"]
data.match(/windows (\d+)/) // ["windows 98", "98"]

/* 后行断言 es10
let test = 'world hello'
test.match(/(?<=world\s)hello/)         // ["hello", index: 6, input: "world hello", groups: undefined]
(?<…)是后行断言的符号，(?..)是先行断言的符号，然后结合 =(等于)、!(不等)、\1(捕获匹配)。
 * */

// (?!pattern) 零宽负向先行断言
// (?<!pattern) 零宽负向后行断言
// str = "hello&nbsp;&test1;test&qout;";
// 正则表达式：/&((?!test).)+;/g

/* 反向引用
    let reg = /(\w)\1/g     \1反向引用第一个子表达式(第一个括号内的)的内容
    let reg = /(\w)\1(\w)\2/g   ('aabb').replace(reg,'$2$2$1$1')    :aabb -> bbaa
                                ('aabb').replace(reg, function($, $1, $2){ return $2 + $2 + $1 + $1 })
 * */

/*
[]              [^a | ^b]       非a或非b
(abc|bcd)       abd 或 bcd
 * */

/*  量词            默认：贪婪匹配，能多就不少
    n+      {1,}
    n*      {0,}
    n?      {0,1}
    n{x}    x个
    n{x,y}  x-y个
    n{x,}   大于x个

    /n{x,y}?/ 在量词后加？表示开启非贪婪模式，能少就不多
 * */

// uniCode编码      \u000000   4位16进制数字
// 第一层区间 \u010000 -\u01ffff
// 第16层区间 \u100000 -\u10ffff

/*
str 字符串有的方法 -->  match replace search split
                      replace(reg, func (result) {} )  replace可以用回掉函数的形式  
reg 正则对象的方法 -->  test  exec  

reg对象的属性  * lastIndex   global -->g ignoreCase -->i  
                multiline -->m   source -->源文本
                lastIndex   作为游标 ，记录exec方法全局匹配时，每次开始的位置
全局匹配时，游标会向后移，直到匹配成功后停止，之后执行exec会从游标位置开始匹配
会包含子表达式
 * */

/*
 * */
```

### 修饰符

i 忽略大小写 , g 全局匹配 , m 多行匹配

```js
// 换号匹配时能匹配到，两个 a
let reg = /^a/gm
let str = "absnd\nads"
console.log(str.match(reg))
```

### 元字符

```js
// 元字符
/*
    .                   一切
    /d = [0-9]          \D = [^\d]
    \w = [0-9A-z_]      \W = [^\w]
    \s = [\n|\f|\r|\t|\v| ]    \S = [^\s]   空白字符
    \b 单词边界          \B 非单词边界
    例：str = 'i am tree' reg = /\bam\b/
    \uxxxx              uniCode匹配  
    reg = /\u8001/  能匹配汉字  '老'
 * */

// 特殊符号
/*
    转义符号    \
    结束行      \r
    换行        \n  
    制表符，缩进 \t
 * */
```

### 例子

把 the-first-name 变为小驼峰式写法

```js
// 解法一
let reg = /([a-z]+)-([a-z]+)-([a-z]+)/g
let result = str.replace(reg, function ($, $1, $2, $3) {
    console.log($1.split(1))
    return (
        $1 +
        $2[0].toUpperCase() +
        $2.slice(1) +
        $3[0].toUpperCase() +
        $3.slice(1)
    )
})

// 解法二
let reg = /-(\w)/g
let result = str.replace(reg, function ($, $1) {
    //每次匹配到的子表达式,每匹配一次都会执行一次回掉函数
    return $1.toUpperCase()
})
```

把 10000000000 转化为 10.000.000.000

```js
// 解法一
let num = "10000000000"
let newNum = [],
    lastNum = []
for (let i = num.length - 1; i >= 0; i--) {
    newNum.push(num[i])
}
newNum = newNum.join("")
let reg1 = /(\d{3})/g
let backNum = newNum.replace(reg1, "$1.")
for (let i = backNum.length - 1; i >= 0; i--) {
    lastNum.push(backNum[i])
}
let result1 = lastNum.join("")

// 解法二
let reg1 = /(?=(\B)(\d{3})+$)/g
let result1 = num.replace(reg1, ".")
```
